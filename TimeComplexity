주어진 데이터가 n(덩어리) 일 때,

O(nlogn) 과 같은 시간 복잡도 계산은 어떻게 이루어 지는 것일까?

이진 탐색을 예로 들면 , 주어진 데이터를 2로 나누는 행위를 반복 하여 찾는다. 

최악의 경우 주어진 데이터가 1이 될 때까지 2로 나누는 연산을 행해야 하고

그렇다면 그 연산은 n: 1, n/2 : 2 , ... 1 : x 이렇게 된다. 

이 연산에서 다시 n 으로 되돌아가려면 1x2의x승 = n 이라는 방정식을 세울 수 있고

여기서 연산의 횟수인 x를 구하기 위하여 양변에 log를 취하면 log2x승 = logn 이되고 

x = log2n 이된다 


로그 시간 복잡도는 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어들고 


따라서 n 개로 쪼개진 병합 부분 정렬들의 시간 복잡도 1이 되는 시간 복잡도 x는 

n*logN 으로 주어진 데이터 n의 길이에 의해 병합정렬은 이진 탐색처럼 나누지만 끝까지 나누어 표현하므로 

시간 복잡도가 그만큼 줄어들 수 있으므로 병합정렬의 시간 복잡도느 O(n*logN)으로 표기하는 것이다

최종 n 길이 만큼 쪼개진 길이에서 한번 진행하면 줄어든 n만큼 연산 횟수는 줄어듦으로 

n*logN으로 시간 복잡도를 표현할 수 있다

# 여기서 가장 잘 설명함
https://blog.naver.com/ndb796/221227934987


단계의 크기가 N값에 의해 LogN만큼 유지되는 알고리즘이고 , 각 단계에서는 n만큼만 데이터를 읽기 때문에 이 시간 복잡도가 유지되는 알고리즘이다
참고 : https://kjwsx23.tistory.com/339 , https://devlimk1.tistory.com/138#:~:text=%EC%A문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듦0%95%EB%A0%AC(Sort)-,%5B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%A0%95%EB%A0%AC%5D%20%ED%95%A9%EB%B3%91(%EB%B3%91%ED%95%A9)%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98(Merge,%EC%9C%BC%EB%A1%9C%20%ED%95%9C%EB%B0%A9%EC%97%90%20%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90!


# 다음은 재귀함수 

재귀함수는 맨 마지막 호출 되는 함수에서 실행되면서 올라온다 .
