# :bulb: 시간 복잡도의 계산

&nbsp;

### + 주어진 데이터가 n(덩어리) 일 때 O(nlogn) 과 같은 시간 복잡도 계산은 어떻게 이루어 지는 것일까?

#### 우선 이진 탐색은 주어진 데이터를 2로 나누는 행위를 반복하여 찾는다. 

#### 최악의 경우 주어진 데이터가 1이 될 때까지 2로 나누는 연산을 행해야 한다

그렇다면 그 연산의 수열은

n:1, n/2:2, n/4:3,...,1:x  이다. 

연산의 횟수를 x라고 가정하고 

이 연산에서 다시 n을 구하려면  n=1×2x(지수승) 이라는 방정식을 세울 수 있고

여기서 연산의 횟수인 x를 구하기 위하여 양변에 log를 취하면 log2x(지수승) = logn 이되고 

x = log2n 이된다 
 

&nbsp;

로그 시간 복잡도는 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어들고 

따라서 n 개로 쪼개진 병합 부분 정렬들의 시간 복잡도 1이 되는 시간 복잡도 x는 

n*logN 으로 주어진 데이터 n의 길이에 의해 병합정렬은 이진 탐색처럼 나누지만 끝까지 나누어 표현하므로 

시간 복잡도가 그만큼 줄어들 수 있으므로 병합정렬의 시간 복잡도느 O(n*logN)으로 표기하는 것이다

최종 n 길이 만큼 쪼개진 길이에서 한번 진행하면 줄어든 n만큼 연산 횟수는 줄어듦으로 

n*logN으로 시간 복잡도를 표현할 수 있다

시간 복잡도가 O(n*logN)인 알고리즘이란,

단계의 크기가 N값에 의해 LogN만큼 유지되는 알고리즘이고 , 각 단계에서는 n만큼만 데이터를 읽기 때문에 이 시간 복잡도가 유지되는 알고리즘이다


병합정렬의 시간 복잡도는 입력 데이터 n 이 1개가 될 때까지 나누는 수행횟수 logn에 각 수행에서 총 n 길이만큼 이중 for문을 돌며 비교하여 삽입하기 때문에 n 수행횟수를 곱하여
O(NlogN) 으로 표현된다.
&nbsp;


# 참고
https://blog.naver.com/ndb796/221227934987 https://kjwsx23.tistory.com/339 , https://devlimk1.tistory.com/138#:~:text=%EC%A

&nbsp;

log 시간 복잡도는 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듦0%95%EB%A0%AC(Sort)-,%5B%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%A0%95%EB%A0%AC%5D%20%ED%95%A9%EB%B3%91(%EB%B3%91%ED%95%A9)%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98(Merge,%EC%9C%BC%EB%A1%9C%20%ED%95%9C%EB%B0%A9%EC%97%90%20%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90!


